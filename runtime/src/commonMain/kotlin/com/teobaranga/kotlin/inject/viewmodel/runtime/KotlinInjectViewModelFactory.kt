package com.teobaranga.kotlin.inject.viewmodel.runtime

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewmodel.CreationExtras
import me.tatarka.inject.annotations.Inject
import kotlin.reflect.KClass

val CREATION_CALLBACK_KEY = object : CreationExtras.Key<CreationExtras.(Any) -> ViewModel> {}

/**
 * [ViewModelProvider.Factory] that uses ViewModel factories generated by kotlin-inject.
 *
 * Supports both ViewModels that have no assisted dependencies (ie. everything provided by the DI graph)
 * as well as ViewModels that require them.
 */
@Inject
class KotlinInjectViewModelFactory(
    /**
     * Map of simple ViewModel factories for ViewModels that have no assisted dependencies.
     */
    private val viewModelMap: Map<KClass<out ViewModel>, () -> ViewModel> = emptyMap(),

    /**
     * Map of advanced ViewModel factories that require one or more assisted dependencies including [SavedStateHandle].
     */
    private val viewModelFactoryMap: Map<KClass<out ViewModel>, Any> = emptyMap(),
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: KClass<T>, extras: CreationExtras): T {
        return viewModelMap[modelClass]?.invoke() as T?
            ?: run {
                // The callback is meant to use an existing factory and provide the remaining
                // assisted dependencies to complete the creation of the ViewModel.
                val callback = extras[CREATION_CALLBACK_KEY] ?: return@run null
                val viewModelFactory = viewModelFactoryMap[modelClass] ?: return@run null
                with(extras) {
                    callback(viewModelFactory) as? T
                }
            }
            ?: error("No view model found for $modelClass")
    }
}
